<script type="module">
    // ----------------------------------------------------------------------------------
    // FONCTION POUR AFFICHER LA DATE
    // ----------------------------------------------------------------------------------
    function displayCurrentDate() {
        const dateElement = document.getElementById('current-date');
        const options = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
        const today = new Date();
        // Affichage de la date formatée en français
        dateElement.textContent = today.toLocaleDateString('fr-FR', options);
    }

    // ----------------------------------------------------------------------------------
    // 1. Initialisation Supabase
    // ----------------------------------------------------------------------------------
    import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'
    
    const SUPABASE_URL = 'https://ejirdcqcmmeybgitonmw.supabase.co'
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVqaXJkY3FjbW1leWJnaXRvbm13Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjE1OTY2MjYsImV4cCI6MjA3NzE3MjYyNn0.4E93ufwJ-RIjV9qT0I4t3GiI9NIzVzN_ktwDPswT7ic'

    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY)
    
    /**
     * NOUVELLE LOGIQUE DE SÉCURITÉ : Vérifie la connexion, le rôle et adapte l'UI.
     * Remplace l'ancienne fonction testConnexion().
     */
    async function checkAuthAndRole() {
        displayCurrentDate(); 

        // Cache le bouton 'Préparation' par défaut au chargement de la page
        document.getElementById('top-left-controls').style.display = 'none'; 

        const icon = document.getElementById('statusIcon')
        const label = document.getElementById('dbLabel')
        const status = document.getElementById('status')

        // --- PARTIE AUTHENTIFICATION ---
        const { data: { session }, error: sessionError } = await supabase.auth.getSession();

        if (!session || sessionError) {
            // REDIRECTION CRITIQUE : L'utilisateur n'est pas logué
            window.location.href = '/login.html'; 
            return; 
        }

        // --- PARTIE AUTORISATION (RÔLE) ---
        try {
            // On vérifie aussi la connexion à la BD en même temps que le rôle
            const { data: profile, error: roleError } = await supabase
                .from('utilisateur autorisation') // **Attention : Le nom de votre table est 'utilisateur autorisation'**
                .select('role')
                .eq('user_id', session.user.id)
                .single();

            if (roleError || !profile) {
                console.error("Erreur de récupération du profil ou rôle manquant. Déconnexion forcée.", roleError);
                // Si l'utilisateur n'a pas de rôle valide (erreur de sécurité), on le déconnecte.
                await supabase.auth.signOut();
                window.location.href = '/login.html';
                return;
            }

            const userRole = profile.role;

            // Contrôle du Front-end : Afficher le bouton si le rôle est suffisant
            if (userRole === 'admin' || userRole === 'preparator') {
                 document.getElementById('top-left-controls').style.display = 'block'; 
            }

            // Met à jour le statut de connexion BD (visuel)
            status.textContent = '' 
            status.style.backgroundColor = 'transparent'
            icon.textContent = '✓' 
            icon.style.color = 'green'
            label.style.color = 'green'

            // Lance l'initialisation des graphiques (qui lira les données avec la session)
            await initCharts(); 

        } catch (e) {
            console.error("Erreur critique d'accès à la BD ou de vérification:", e);
            
            // --- LOGIQUE DE SECOURS (FALLBACK) EN CAS D'ÉCHEC DE CONNEXION À LA BD ---
            status.textContent = '❌ Erreur de connexion aux données'
            status.style.backgroundColor = '#ffdddd'
            icon.textContent = '✕' 
            icon.style.color = 'red'
            label.style.color = 'red'
            
            // Utilise les valeurs de secours si la connexion aux données échoue (similaire à votre ancienne fonction)
            const fallbackTheoretical = Array(12).fill(0); 
            const fallbackReal = [
                5, 15, 28, 32, 80, 82, 82, 82, 82, 87, null, null 
            ];
            const evolutionDataFallback = fallbackReal.map((real, index) => ({
                month: ['Jan', 'Fév', 'Mar', 'Avr', 'Mai', 'Juin', 'Juil', 'Août', 'Sept', 'Oct', 'Nov', 'Déc'][index],
                real: real, 
                theoretical: fallbackTheoretical[index]
            }));
            renderCharts(86.7, 85.5, 3434, 2935, evolutionDataFallback);
        }
    }


    // ----------------------------------------------------------------------------------
    // 2. Fonctions de Récupération des Données (Conservez le code d'origine)
    // ----------------------------------------------------------------------------------
    // NOTE : Ces fonctions utiliseront la session Supabase établie par checkAuthAndRole()
    
    /**
     * Calcule le taux de conformité et de progression en interrogeant la table liste_ddr.
     */
    async function fetchConformiteData() {
        const currentYear = new Date().getFullYear();
        const startOfYear = `${currentYear}-01-01`;
        const endOfYear = `${currentYear}-12-31`;

        // 1. Total DDR Répertorié
        const { count: totalDDR, error: totalError } = await supabase
            .from('liste_ddr')
            .select('*', { count: 'exact', head: true });

        // 2. Total DDR Expirés (Non conformes)
        const { count: expiredDDR, error: expiredError } = await supabase
            .from('liste_ddr')
            .select('*', { count: 'exact', head: true })
            .lt('Date prochain controle', new Date().toISOString().split('T')[0]); 

        // 3. Total DDR à faire / testés cette année (Progression)
        const { count: ddrThisYear, error: ddrThisYearError } = await supabase
            .from('liste_ddr')
            .select('*', { count: 'exact', head: true })
            .gte('Date prochain controle', startOfYear) 
            .lte('Date prochain controle', endOfYear); 

        if (totalError || expiredError || ddrThisYearError || totalDDR === null || expiredDDR === null || ddrThisYear === null) {
            console.error('Erreur lors de la récupération des données de DDR:', totalError || expiredError || ddrThisYearError);
            return null; 
        }

        if (totalDDR === 0) {
            return { conformite: 100, progression: 0, totalDDR: 0, ddrThisYear: 0 };
        }

        const nonConformiteRate = (expiredDDR / totalDDR) * 100;
        const conformiteRate = 100 - nonConformiteRate;
        
        const progressionRate = (ddrThisYear / totalDDR) * 100;

        return { 
            conformite: conformiteRate,
            progression: progressionRate,
            totalDDR: totalDDR, 
            ddrThisYear: ddrThisYear 
        };
    }
    
    /**
     * Récupère les données d'évolution réelle et théorique cumulées par mois.
     */
    async function fetchEvolutionData(totalDDR) {
        if (totalDDR === 0) {
            return Array(12).fill(0).map((_, index) => ({ 
                month: ['Jan', 'Fév', 'Mar', 'Avr', 'Mai', 'Juin', 'Juil', 'Août', 'Sept', 'Oct', 'Nov', 'Déc'][index],
                real: 0, 
                theoretical: 0 
            }));
        }

        const todayDate = new Date();
        const currentYear = todayDate.getFullYear();
        const currentMonth = todayDate.getMonth() + 1; 
        const startOfYear = `${currentYear}-01-01`;

        const evolutionData = [];
        
        for (let month = 1; month <= 12; month++) {
            const monthLabel = ['Jan', 'Fév', 'Mar', 'Avr', 'Mai', 'Juin', 'Juil', 'Août', 'Sept', 'Oct', 'Nov', 'Déc'][month - 1];
            let realPercentage = null; 
            let theoreticalPercentage = 0;
            
            // --- LOGIQUE DE PROGRESSION THÉORIQUE ---
            const plannedEndDateFilter = new Date(currentYear, month, 0).toISOString().split('T')[0];
            const { count: plannedUpToMonth, error: plannedError } = await supabase
                .from('liste_ddr')
                .select('*', { count: 'exact', head: true })
                .lte('Date planifiee', plannedEndDateFilter)
                .gte('Date planifiee', startOfYear); 

            if (!plannedError) {
                theoreticalPercentage = (plannedUpToMonth || 0) / totalDDR * 100;
            }

            // --- LOGIQUE DE PROGRESSION RÉELLE ---
            if (month <= currentMonth) {
                let realEndDateFilter;
                if (month === currentMonth) {
                    realEndDateFilter = todayDate.toISOString().split('T')[0];
                } else {
                    realEndDateFilter = plannedEndDateFilter; 
                }

                const { count: testedUpToMonth, error: realError } = await supabase
                    .from('liste_ddr')
                    .select('*', { count: 'exact', head: true })
                    .lte('Date de dernier controle', realEndDateFilter)
                    .gte('Date de dernier controle', startOfYear); 

                if (!realError) {
                    realPercentage = (testedUpToMonth || 0) / totalDDR * 100;
                }
            }
            
            evolutionData.push({ 
                month: monthLabel,
                real: realPercentage, 
                theoretical: theoreticalPercentage 
            });
        }

        return evolutionData;
    }
    
    // ----------------------------------------------------------------------------------
    // 3. Fonction Principale d'Initialisation
    // ----------------------------------------------------------------------------------

    async function initCharts() {
        const conformiteData = await fetchConformiteData();
        
        // Définition des données à utiliser (réelles ou statiques de repli)
        const conformite = conformiteData ? conformiteData.conformite : 86.7; 
        const progression = conformiteData ? conformiteData.progression : 85.5; 
        const totalPlanifie = conformiteData ? conformiteData.totalDDR : 3434; 
        const ddrThisYear = conformiteData ? conformiteData.ddrThisYear : 2935; 
        
        // Récupération des données d'évolution réelle et théorique DYNAMIQUES
        const evolutionData = conformiteData 
            ? await fetchEvolutionData(conformiteData.totalDDR) 
            : null;

        // --- LOGIQUE DE SECOURS (FALLBACK) EN CAS D'ÉCHEC DE fetchConformiteData ---
        const fallbackTheoretical = Array(12).fill(0); 
        const fallbackReal = [
            5, 15, 28, 32, 80, 82, 82, 82, 82, 87, null, null
        ];
        
        const evolutionDataFallback = fallbackReal.map((real, index) => ({
            month: ['Jan', 'Fév', 'Mar', 'Avr', 'Mai', 'Juin', 'Juil', 'Août', 'Sept', 'Oct', 'Nov', 'Déc'][index],
            real: real, 
            theoretical: fallbackTheoretical[index]
        }));
        // --------------------------------------------------------------------------------------
        
        // Rendu des graphiques
        // Utilise les données dynamiques si disponibles, sinon les données de secours
        renderCharts(conformite, progression, totalPlanifie, ddrThisYear, evolutionData || evolutionDataFallback);
    }

    // ----------------------------------------------------------------------------------
    // 4. Fonction de Rendu (Conservez le code d'origine)
    // ----------------------------------------------------------------------------------

    function renderCharts(conformite, progression, totalPlanifie, ddrThisYear, evolutionData) {
        // COULEURS DU THÈME
        const successColor = '#4caf50'; // Vert
        const primaryColor = '#0078d7'; // Bleu
        const greyColor = '#e0e0e0';
        
        // Mise à jour des valeurs textuelles
        document.getElementById('conformite-value').textContent = conformite.toFixed(1).replace('.', ',') + ' %';
        document.getElementById('totalPlanifie').textContent = totalPlanifie; // DDR Répertorié
        document.getElementById('totalTestes').textContent = ddrThisYear; // DDR Testé

        // 1. Graphique de Conformité (Barre verticale)
        const conformiteCtx = document.getElementById('conformiteChart').getContext('2d');
        if (Chart.getChart(conformiteCtx)) Chart.getChart(conformiteCtx).destroy();
        new Chart(conformiteCtx, {
            type: 'bar',
            data: {
                labels: [''],
                datasets: [
                    {
                        label: 'Manquant',
                        data: [100 - conformite],
                        backgroundColor: greyColor, 
                        borderRadius: 10,
                    },
                    {
                        label: 'Conformité',
                        data: [conformite],
                        backgroundColor: successColor, 
                        borderWidth: 2,
                        borderRadius: 10,
                    }
                ]
            },
            options: {
                responsive: true, 
                maintainAspectRatio: false,
                scales: { 
                    x: { display: false, stacked: true }, 
                    y: { display: false, stacked: true, max: 100, reverse: true } 
                },
                plugins: { legend: { display: false }, tooltip: { enabled: false } }
            }
        });


        // 2. Graphique de Progression (Anneau - utilise maintenant la Progression calculée)
        const progressionCtx = document.getElementById('progressionChart').getContext('2d');
        if (Chart.getChart(progressionCtx)) Chart.getChart(progressionCtx).destroy();
        new Chart(progressionCtx, {
            type: 'doughnut',
            data: {
                labels: ['Prévus cette année', 'Hors année'],
                datasets: [{
                    data: [progression, 100 - progression],
                    backgroundColor: [successColor, greyColor], 
                    borderWidth: 0,
                }]
            },
            options: {
                responsive: true, maintainAspectRatio: false, cutout: '70%', 
                plugins: { legend: { display: false }, tooltip: { enabled: false } }
            },
            plugins: [{
                id: 'textCenter',
                beforeDatasetsDraw(chart, args, pluginOptions) {
                    const { ctx, data, chartArea: { top, width, height } } = chart;
                    ctx.save();
                    ctx.font = 'bolder 2em Arial'; 
                    ctx.fillStyle = '#333'; 
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(data.datasets[0].data[0].toFixed(1).replace('.', ',') + ' %', width / 2, height / 2 + top);
                    ctx.restore();
                }
            }]
        });


        // 3. Graphique d'Évolution (Ligne)
        const evolutionCtx = document.getElementById('evolutionChart').getContext('2d');
        if (Chart.getChart(evolutionCtx)) Chart.getChart(evolutionCtx).destroy();
        new Chart(evolutionCtx, {
            type: 'line',
            data: {
                labels: evolutionData.map(d => d.month),
                datasets: [
                    {
                        label: 'Progression réelle',
                        data: evolutionData.map(d => d.real), // Données réelles
                        borderColor: successColor, backgroundColor: 'transparent',
                        tension: 0.2, pointRadius: 3, borderWidth: 3
                    },
                    {
                        label: 'Progression théorique',
                        data: evolutionData.map(d => d.theoretical), 
                        borderColor: primaryColor, backgroundColor: 'transparent',
                        borderDash: [5, 5], tension: 0.2, pointRadius: 0, borderWidth: 2
                    }
                ]
            },
            options: {
                responsive: true, maintainAspectRatio: false,
                plugins: {
                    legend: { position: 'top', labels: { usePointStyle: true, } },
                    tooltip: {
                        mode: 'index', intersect: false,
                        callbacks: { 
                            label: (context) => context.dataset.label + ': ' + (context.parsed.y !== null ? context.parsed.y.toFixed(1).replace('.', ',') + ' %' : 'N/A') 
                        }
                    }
                },
                scales: {
                    y: { beginAtZero: true, max: 100, title: { display: false }, ticks: { callback: (value) => value + ' %' } },
                    x: { grid: { display: false } }
                }
            }
        });
    }

    // ----------------------------------------------------------------------------------
    // APPEL FINAL : Lance le processus de vérification de l'accès (NOUVEAU)
    // ----------------------------------------------------------------------------------
    checkAuthAndRole();
  </script>